# -*- coding: utf-8 -*-
"""Untitled

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1FpnMlP2wbrqyYLlKmIRAHmriAc-1s_c-
"""

# prompt: import pandas

import pandas as pd

# prompt: import /content/Riya Maithani - revolutioncart_data.csv

import pandas as pd
df = pd.read_csv('/content/Riya Maithani - revolutioncart_data.csv')

df

# prompt: consider monthly_revenue as y and rest as X

X = df.drop('monthly_revenue', axis=1)
y = df['monthly_revenue']

# prompt: split the data into X_train and y_train

from sklearn.model_selection import train_test_split

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# prompt: create model linear regression

from sklearn.linear_model import LinearRegression

model = LinearRegression()
model.fit(X_train, y_train)

# prompt: predict the accuracy and analyse the model

from sklearn.metrics import mean_squared_error, r2_score

y_pred = model.predict(X_test)

# Evaluate the model
mse = mean_squared_error(y_test, y_pred)
r2 = r2_score(y_test, y_pred)

print(f"Mean Squared Error: {mse}")
print(f"R-squared: {r2}")

# Analyze the model
# You can examine the coefficients of the model to understand the relationship between
# each feature and the target variable.
print("Coefficients:", model.coef_)

# You can also create a scatter plot of the predicted values vs. the actual values to
# visually assess the model's performance.
import matplotlib.pyplot as plt
plt.scatter(y_test, y_pred)
plt.xlabel("Actual Monthly Revenue")
plt.ylabel("Predicted Monthly Revenue")
plt.title("Actual vs. Predicted Monthly Revenue")
plt.show()

# prompt: do cross validation and do the predictions

import matplotlib.pyplot as plt
from sklearn.model_selection import cross_val_predict

# Perform cross-validation and get predictions
y_pred_cv = cross_val_predict(model, X, y, cv=5)  # Use 5-fold cross-validation

# Evaluate the model with cross-validated predictions
mse_cv = mean_squared_error(y, y_pred_cv)
r2_cv = r2_score(y, y_pred_cv)

print(f"Mean Squared Error (Cross-validated): {mse_cv}")
print(f"R-squared (Cross-validated): {r2_cv}")

# You can also create a scatter plot of the cross-validated predicted values vs. the actual values
plt.scatter(y, y_pred_cv)
plt.xlabel("Actual Monthly Revenue")
plt.ylabel("Predicted Monthly Revenue (Cross-validated)")
plt.title("Actual vs. Predicted Monthly Revenue (Cross-validated)")
plt.show()

# prompt: dump the model

import pickle

# Save the model to a file
filename = 'linear_regression_model.sav'
pickle.dump(model, open(filename, 'wb'))

# prompt: create support vector regression model

import matplotlib.pyplot as plt
from sklearn.svm import SVR

# Create and train the SVR model
svr_model = SVR(kernel='linear')  # You can choose different kernels (e.g., 'rbf', 'poly')
svr_model.fit(X_train, y_train)

# Make predictions
y_pred_svr = svr_model.predict(X_test)

# Evaluate the model
mse_svr = mean_squared_error(y_test, y_pred_svr)
r2_svr = r2_score(y_test, y_pred_svr)

print(f"SVR Mean Squared Error: {mse_svr}")
print(f"SVR R-squared: {r2_svr}")

# Plot actual vs. predicted values for SVR
plt.scatter(y_test, y_pred_svr)
plt.xlabel("Actual Monthly Revenue")
plt.ylabel("Predicted Monthly Revenue (SVR)")
plt.title("Actual vs. Predicted Monthly Revenue (SVR)")
plt.show()

# Perform cross-validation and get predictions for SVR
y_pred_cv_svr = cross_val_predict(svr_model, X, y, cv=5)

# Evaluate the model with cross-validated predictions for SVR
mse_cv_svr = mean_squared_error(y, y_pred_cv_svr)
r2_cv_svr = r2_score(y, y_pred_cv_svr)

print(f"SVR Mean Squared Error (Cross-validated): {mse_cv_svr}")
print(f"SVR R-squared (Cross-validated): {r2_cv_svr}")

# Plot actual vs. cross-validated predicted values for SVR
plt.scatter(y, y_pred_cv_svr)
plt.xlabel("Actual Monthly Revenue")
plt.ylabel("Predicted Monthly Revenue (SVR, Cross-validated)")
plt.title("Actual vs. Predicted Monthly Revenue (SVR, Cross-validated)")
plt.show()

# Save the SVR model to a file (optional)
filename_svr = 'svr_model.sav'
pickle.dump(svr_model, open(filename_svr, 'wb'))

# Commented out IPython magic to ensure Python compatibility.
# # prompt: generate code for streamlit app
# 
# %%writefile app.py
# import streamlit as st
# import pandas as pd
# import pickle
# import matplotlib.pyplot as plt
# 
# # Load the trained model
# filename = 'linear_regression_model.sav'
# model = pickle.load(open(filename, 'rb'))
# 
# # Load the SVR model
# filename_svr = 'svr_model.sav'
# svr_model = pickle.load(open(filename_svr, 'rb'))
# 
# # Create a title for the app
# st.title("Monthly Revenue Prediction App")
# 
# # Create input fields for the features
# st.header("Input Features:")
# website_traffic = st.number_input("Website Traffic")
# marketing_spend = st.number_input("Marketing Spend")
# customer_acquisition_cost = st.number_input("Customer Acquisition Cost")
# average_order_value = st.number_input("Average Order Value")
# conversion_rate = st.number_input("Conversion Rate")
# 
# 
# # Create a button to make predictions
# if st.button("Predict Monthly Revenue"):
#     # Create a DataFrame with the user's input
#     input_data = pd.DataFrame({
#         'website_traffic': [website_traffic],
#         'marketing_spend': [marketing_spend],
#         'customer_acquisition_cost': [customer_acquisition_cost],
#         'average_order_value': [average_order_value],
#         'conversion_rate': [conversion_rate]
#     })
# 
#     # Make predictions using the linear regression model
#     predicted_revenue_linear = model.predict(input_data)[0]
# 
#     # Make predictions using the SVR model
#     predicted_revenue_svr = svr_model.predict(input_data)[0]
# 
#     # Display the predictions
#     st.header("Predictions:")
#     st.write(f"Predicted Monthly Revenue (Linear Regression): {predicted_revenue_linear:.2f}")
#     st.write(f"Predicted Monthly Revenue (SVR): {predicted_revenue_svr:.2f}")
# 
# # You can add more features and functionalities to your app, such as:
# # - Visualizing the model's performance using charts and graphs
# # - Providing explanations for the predictions
# # - Allowing users to upload their own data
# # - Adding a section for model comparison
#